#pragma kernel main

struct seed
{
    float3 position;
    float radius;
};

RWTexture3D<float4> result;
RWStructuredBuffer<seed> buffer;

float4x4 volume_local_to_world;
int3 resolution;
float delta;

[numthreads(8,8,8)]
void main (const uint3 id : SV_DispatchThreadID)
{
    result[id].a -= delta * 0.5;
    
    const float3 uv = id.xyz / float3(resolution.x - 1, resolution.y - 1, resolution.z - 1);
    const float3 local = uv.xyz - .5;
    const float3 world = mul(volume_local_to_world, float4(local, 1));

    uint length, stride;
    buffer.GetDimensions(length, stride);
    
    float4 new_value = float4(0, 0, 0, 0);
    
    for (uint i = 0; i < length; i++)
    {
        const float dist = distance(world, buffer[i].position);
        const float strength = 1 - dist / buffer[i].radius;
        if (strength >= new_value.a)
        {
            float3 to_seed = (normalize(float3(buffer[i].position - world)) + 1) * 0.5;
            new_value = float4(to_seed, strength);
        }
    }
    
    if (id.x == 0 || id.x == resolution.x - 1 || id.y == 0 || id.y == resolution.y - 1 || id.z == 0 || id.z == resolution.z - 1)
        new_value = float4(0, 0, 0, 0);

    // TODO: Replace linear interpolation with a 'move towards' function.
    // result[id] = lerp(result[id], new_value, delta / .25);
    result[id] = new_value.a > 0 ? new_value : result[id];
}
