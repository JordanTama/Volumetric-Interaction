#include "VolumetricInteractionCompute.cginc"

#pragma kernel main

[numthreads(8,8,8)]
void main (const uint3 id : SV_DispatchThreadID)
{
    // First thing to do is decay the texture.
    result[id.xyz].a = move_towards(result[id.xyz].a, 0, 0.5 * delta);
    
    const float3 uv = id.xyz / float3(resolution.x - 1, resolution.y - 1, resolution.z - 1);
    const float3 local = uv.xyz - .5;
    const float3 world = mul(volume_local_to_world, float4(local, 1));

    uint length, stride;
    buffer.GetDimensions(length, stride);
    
    float4 new_value = float4(0.5, 0.5, 0.5, 0);
    
    for (uint i = 0; i < length; i++)
    {
        const float dist = distance(world, buffer[i].position);
        const float strength = 1 - dist / buffer[i].radius;
        if (strength >= new_value.a)
        {
            float3 to_seed = (normalize(float3(buffer[i].position - world)) + 1) * 0.5;
            new_value = float4(to_seed, strength);
        }
    }

    // Edge pixels are blank so that repeating the texture doesn't actually draw it.
    if (id.x == 0 || id.x == resolution.x - 1 || id.y == 0 || id.y == resolution.y - 1 || id.z == 0 || id.z == resolution.z - 1)
        new_value = float4(0, 0, 0, 0);

    float4 previous_value = result[id];
    float4 final_value = float4(previous_value.xyz, max(previous_value.a, new_value.a));

    const float t_a = new_value.a + previous_value.a;
    if (t_a > 0)
        final_value.xyz = (new_value.xyz * (new_value.a / t_a)) + (previous_value.xyz * (previous_value.a / t_a));
    
    result[id] = final_value;
}
